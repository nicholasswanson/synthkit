<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Synthkit</title>
    <meta name="description" content="Prototype with realistic, synthetic datasets">
    
    <!-- Use Tailwind CDN for immediate styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        orange: {
                            500: '#ff6b35',
                            100: '#ffccb4',
                            200: '#ffb896'
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Custom styles for the orange theme */
        .btn-orange {
            background-color: #ffccb4;
            color: #ff6b35;
        }
        .btn-orange:hover {
            background-color: #ffb896;
        }
        .btn-orange:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .border-orange {
            border-left-color: #ff6b35;
        }
        .focus-orange:focus {
            outline: none;
            ring: 2px;
            ring-color: #ff6b35;
            border-color: #ff6b35;
        }
    </style>
</head>
<body class="min-h-screen bg-white">
    <div class="flex h-screen">
        <!-- Left Panel -->
        <div class="w-3/10 overflow-y-auto bg-white" style="padding:40px;width:30%">
            <div class="max-w-4xl mx-auto">
                <!-- Header -->
                <div class="text-center mb-8">
                    <div class="flex items-center justify-center mb-4">
                        <div class="w-16 h-16 bg-orange-500 rounded-lg flex items-center justify-center text-white font-bold text-xl">S</div>
                    </div>
                    <p class="text-lg text-gray-600">Prototype with realistic, synthetic datasets</p>
                </div>

                <!-- Configuration -->
                <div class="mb-8">
                    <h3 class="text-xl font-semibold text-gray-900 mb-4">Configuration</h3>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Pre-built scenarios</label>
                        <select id="scenario-select" class="w-full px-3 py-2 pr-8 border border-gray-300 rounded-xl focus-orange text-gray-900 appearance-none bg-white">
                            <option value="checkout-ecommerce" selected>Checkout e-commerce</option>
                            <option value="b2b-saas-subscriptions">B2B SaaS subscriptions</option>
                            <option value="food-delivery-platform">Food delivery platform</option>
                            <option value="consumer-fitness-app">Consumer fitness app</option>
                            <option value="b2b-invoicing">B2B invoicing</option>
                            <option value="property-management-platform">Property management platform</option>
                            <option value="creator-platform">Creator platform</option>
                            <option value="donation-marketplace">Donation marketplace</option>
                        </select>
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Custom scenario</label>
                        <textarea id="custom-scenario" placeholder="e.g. birdwatching app with subscriptions" class="w-full px-3 py-2 border border-gray-300 rounded-xl focus-orange resize-none text-gray-900 mb-2" rows="3"></textarea>
                        <button id="generate-custom" disabled class="w-full flex items-center justify-center gap-2 px-4 py-2 rounded-xl transition-colors text-sm font-medium btn-orange">
                            Generate
                        </button>
                    </div>
                </div>

                <!-- Settings -->
                <div class="mb-8">
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Role</label>
                            <select id="role-select" class="w-full px-3 py-2 pr-8 border border-gray-300 rounded-xl focus-orange text-gray-900 appearance-none bg-white">
                                <option value="admin" selected>Admin</option>
                                <option value="support">Support</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Stage</label>
                            <select id="stage-select" class="w-full px-3 py-2 pr-8 border border-gray-300 rounded-xl focus-orange text-gray-900 appearance-none bg-white">
                                <option value="early">Early</option>
                                <option value="growth" selected>Growth</option>
                                <option value="enterprise">Enterprise</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">ID</label>
                            <p class="text-xs text-gray-500 mb-2">Change this number to generate different datasets with unique URLs</p>
                            <input type="number" id="scenario-id" class="w-full px-3 py-2 border border-gray-300 rounded-xl focus-orange text-gray-900" value="12345">
                        </div>
                    </div>
                </div>

                <!-- Dataset Structure (Dynamic) -->
                <div id="dataset-structure-section" class="mb-8">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Included Metrics (Dynamic) -->
                <div id="included-metrics-section" class="mb-8">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Stripe Products (Dynamic) -->
                <div id="stripe-products-section" class="mb-8">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- User Roles -->
                <div class="mb-8">
                    <h3 class="text-xl font-semibold text-gray-900 mb-4">User roles</h3>
                    <div class="space-y-3">
                        <div class="border-l-4 pl-4 border-orange">
                            <div class="font-medium text-gray-900">Admin</div>
                            <div class="text-sm text-gray-600">Complete system access</div>
                            <div class="flex flex-wrap gap-1 mt-1">
                                <span class="px-2 py-1 bg-gray-100 text-gray-800 rounded-xl text-xs">Full Access</span>
                                <span class="px-2 py-1 bg-gray-100 text-gray-800 rounded-xl text-xs">Financial Data</span>
                                <span class="px-2 py-1 bg-gray-100 text-gray-800 rounded-xl text-xs">User Management</span>
                            </div>
                        </div>
                        <div class="border-l-4 pl-4 border-orange">
                            <div class="font-medium text-gray-900">Support</div>
                            <div class="text-sm text-gray-600">Customer service access</div>
                            <div class="flex flex-wrap gap-1 mt-1">
                                <span class="px-2 py-1 bg-gray-100 text-gray-800 rounded-xl text-xs">Customer Support</span>
                                <span class="px-2 py-1 bg-gray-100 text-gray-800 rounded-xl text-xs">Order Management</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="w-7/10 overflow-y-auto bg-gray-50" style="padding:40px;width:70%">
            <!-- Dataset Publishing -->
            <div class="mb-6">
                <div id="dataset-url">
                    <div class="p-3 bg-gray-100 rounded-xl">
                        <div class="flex items-center gap-3">
                            <input type="text" id="url-input" class="flex-1 px-3 py-2 border border-gray-300 rounded-lg text-sm font-mono bg-white" readonly>
                            <button id="copy-url" class="px-3 py-2 text-sm font-medium rounded-xl transition-colors bg-blue-100 text-blue-700 hover:bg-blue-200">Copy URL</button>
                            <button id="update-dataset" class="px-3 py-2 text-sm font-medium rounded-xl transition-colors bg-orange-100 text-orange-700 hover:bg-orange-200">Update Dataset</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="mb-6">
                <div class="flex space-x-1 bg-gray-100 rounded-xl p-1">
                    <button id="tab-cursor" class="flex-1 px-3 py-2 text-sm font-medium rounded-xl transition-colors bg-white text-gray-900 shadow-sm">Cursor</button>
                    <button id="tab-v0" class="flex-1 px-3 py-2 text-sm font-medium rounded-xl transition-colors text-gray-600 hover:text-gray-900">V0</button>
                    <button id="tab-claude" class="flex-1 px-3 py-2 text-sm font-medium rounded-xl transition-colors text-gray-600 hover:text-gray-900">Claude</button>
                    <button id="tab-codex" class="flex-1 px-3 py-2 text-sm font-medium rounded-xl transition-colors text-gray-600 hover:text-gray-900">Codex</button>
                    <button id="tab-javascript" class="flex-1 px-3 py-2 text-sm font-medium rounded-xl transition-colors text-gray-600 hover:text-gray-900">Javascript</button>
                </div>
            </div>


            <!-- Integration Content -->
            <div id="integration-content">
                <div class="space-y-4">
                    <div class="p-4 bg-blue-100 rounded-xl">
                        <p class="text-sm text-blue-700">
                            âœ… Dataset ready! Integration prompts are available below with your current configuration.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Test if JavaScript is working
        console.log('JavaScript is working!');
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM is loaded');
        });
        
        // ============================================================================
        // COMPLETE DATA GENERATION SYSTEM (RESTORED FROM NEXT-APP)
        // ============================================================================
        
        // PREDEFINED PERSONAS (EXACT SAME AS ORIGINAL NEXT-APP)
        const PREDEFINED_PERSONAS = {
            'checkout-ecommerce': {
                name: 'Checkout e-commerce',
                businessContext: {
                    type: 'Checkout e-commerce',
                    stage: 'growth',
                    primaryFeatures: ['Product Catalog', 'Shopping Cart', 'Payment Processing', 'User Reviews'],
                    targetAudience: ['Fashion Enthusiasts', 'Online Shoppers', 'Trend Followers'],
                    monetizationModel: 'E-commerce Sales'
                },
                entities: [
                    { name: 'Customer', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'Full customer name' },
                        { name: 'email', type: 'string', description: 'Customer email address' },
                        { name: 'loyaltyTier', type: 'string', description: 'Bronze, Silver, or Gold tier' }
                    ]},
                    { name: 'Payment', type: 'transaction', properties: [
                        { name: 'amount', type: 'number', description: 'Payment amount in dollars' },
                        { name: 'status', type: 'string', description: 'Payment status' },
                        { name: 'paymentMethod', type: 'string', description: 'Payment method used' }
                    ]}
                ],
                keyFeatures: ['Product Catalog', 'Shopping Cart', 'Payment Processing', 'User Reviews'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            },
            'b2b-saas-subscriptions': {
                name: 'B2B SaaS subscriptions',
                businessContext: {
                    type: 'B2B SaaS subscriptions',
                    stage: 'growth',
                    primaryFeatures: ['User Management', 'Subscription Billing', 'Analytics Dashboard', 'API Access'],
                    targetAudience: ['Business Teams', 'Enterprise Users', 'Developers'],
                    monetizationModel: 'Subscription Revenue'
                },
                entities: [
                    { name: 'Customer', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'Company name' },
                        { name: 'email', type: 'string', description: 'Primary contact email' },
                        { name: 'plan', type: 'string', description: 'Subscription plan tier' }
                    ]},
                    { name: 'Subscription', type: 'transaction', properties: [
                        { name: 'amount', type: 'number', description: 'Monthly subscription amount' },
                        { name: 'status', type: 'string', description: 'Subscription status' },
                        { name: 'billingCycle', type: 'string', description: 'Billing frequency' }
                    ]}
                ],
                keyFeatures: ['User Management', 'Subscription Billing', 'Analytics Dashboard', 'API Access'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            },
            'food-delivery-platform': {
                name: 'Food delivery platform',
                businessContext: {
                    type: 'Food delivery platform',
                    stage: 'growth',
                    primaryFeatures: ['Restaurant Listings', 'Order Management', 'Delivery Tracking', 'Payment Processing'],
                    targetAudience: ['Food Lovers', 'Busy Professionals', 'Families'],
                    monetizationModel: 'Commission-based Revenue'
                },
                entities: [
                    { name: 'Customer', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'Customer name' },
                        { name: 'email', type: 'string', description: 'Customer email' },
                        { name: 'address', type: 'string', description: 'Delivery address' }
                    ]},
                    { name: 'Order', type: 'transaction', properties: [
                        { name: 'amount', type: 'number', description: 'Order total' },
                        { name: 'status', type: 'string', description: 'Order status' },
                        { name: 'restaurant', type: 'string', description: 'Restaurant name' }
                    ]}
                ],
                keyFeatures: ['Restaurant Listings', 'Order Management', 'Delivery Tracking', 'Payment Processing'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            },
            'consumer-fitness-app': {
                name: 'Consumer fitness app',
                businessContext: {
                    type: 'Consumer fitness app',
                    stage: 'growth',
                    primaryFeatures: ['Workout Tracking', 'Progress Analytics', 'Social Features', 'Premium Subscriptions'],
                    targetAudience: ['Fitness Enthusiasts', 'Health-conscious Users', 'Athletes'],
                    monetizationModel: 'Freemium with Premium Subscriptions'
                },
                entities: [
                    { name: 'User', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'User name' },
                        { name: 'email', type: 'string', description: 'User email' },
                        { name: 'subscription', type: 'string', description: 'Premium subscription status' }
                    ]},
                    { name: 'Workout', type: 'transaction', properties: [
                        { name: 'duration', type: 'number', description: 'Workout duration in minutes' },
                        { name: 'type', type: 'string', description: 'Workout type' },
                        { name: 'calories', type: 'number', description: 'Calories burned' }
                    ]}
                ],
                keyFeatures: ['Workout Tracking', 'Progress Analytics', 'Social Features', 'Premium Subscriptions'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            },
            'b2b-invoicing': {
                name: 'B2B invoicing',
                businessContext: {
                    type: 'B2B invoicing',
                    stage: 'growth',
                    primaryFeatures: ['Invoice Generation', 'Payment Tracking', 'Client Management', 'Financial Reporting'],
                    targetAudience: ['Small Businesses', 'Freelancers', 'Consultants'],
                    monetizationModel: 'Subscription + Transaction Fees'
                },
                entities: [
                    { name: 'Client', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'Client company name' },
                        { name: 'email', type: 'string', description: 'Client contact email' },
                        { name: 'paymentTerms', type: 'string', description: 'Payment terms' }
                    ]},
                    { name: 'Invoice', type: 'transaction', properties: [
                        { name: 'amount', type: 'number', description: 'Invoice amount' },
                        { name: 'status', type: 'string', description: 'Payment status' },
                        { name: 'dueDate', type: 'string', description: 'Due date' }
                    ]}
                ],
                keyFeatures: ['Invoice Generation', 'Payment Tracking', 'Client Management', 'Financial Reporting'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            },
            'property-management-platform': {
                name: 'Property management platform',
                businessContext: {
                    type: 'Property management platform',
                    stage: 'growth',
                    primaryFeatures: ['Property Listings', 'Tenant Management', 'Rent Collection', 'Maintenance Tracking'],
                    targetAudience: ['Property Managers', 'Landlords', 'Real Estate Professionals'],
                    monetizationModel: 'Subscription + Transaction Fees'
                },
                entities: [
                    { name: 'Tenant', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'Tenant name' },
                        { name: 'email', type: 'string', description: 'Tenant email' },
                        { name: 'property', type: 'string', description: 'Property address' }
                    ]},
                    { name: 'Rent', type: 'transaction', properties: [
                        { name: 'amount', type: 'number', description: 'Monthly rent amount' },
                        { name: 'status', type: 'string', description: 'Payment status' },
                        { name: 'dueDate', type: 'string', description: 'Due date' }
                    ]}
                ],
                keyFeatures: ['Property Listings', 'Tenant Management', 'Rent Collection', 'Maintenance Tracking'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            },
            'creator-platform': {
                name: 'Creator platform',
                businessContext: {
                    type: 'Creator platform',
                    stage: 'growth',
                    primaryFeatures: ['Content Creation', 'Monetization Tools', 'Audience Analytics', 'Fan Engagement'],
                    targetAudience: ['Content Creators', 'Influencers', 'Artists'],
                    monetizationModel: 'Commission + Subscription Revenue'
                },
                entities: [
                    { name: 'Creator', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'Creator name' },
                        { name: 'email', type: 'string', description: 'Creator email' },
                        { name: 'category', type: 'string', description: 'Content category' }
                    ]},
                    { name: 'Earning', type: 'transaction', properties: [
                        { name: 'amount', type: 'number', description: 'Earning amount' },
                        { name: 'source', type: 'string', description: 'Revenue source' },
                        { name: 'status', type: 'string', description: 'Payment status' }
                    ]}
                ],
                keyFeatures: ['Content Creation', 'Monetization Tools', 'Audience Analytics', 'Fan Engagement'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            },
            'donation-marketplace': {
                name: 'Donation marketplace',
                businessContext: {
                    type: 'Donation marketplace',
                    stage: 'growth',
                    primaryFeatures: ['Campaign Management', 'Donation Processing', 'Impact Tracking', 'Donor Engagement'],
                    targetAudience: ['Nonprofits', 'Charitable Organizations', 'Fundraisers'],
                    monetizationModel: 'Transaction Fees + Platform Fees'
                },
                entities: [
                    { name: 'Donor', type: 'person', properties: [
                        { name: 'name', type: 'string', description: 'Donor name' },
                        { name: 'email', type: 'string', description: 'Donor email' },
                        { name: 'totalDonated', type: 'number', description: 'Total amount donated' }
                    ]},
                    { name: 'Donation', type: 'transaction', properties: [
                        { name: 'amount', type: 'number', description: 'Donation amount' },
                        { name: 'campaign', type: 'string', description: 'Campaign name' },
                        { name: 'status', type: 'string', description: 'Payment status' }
                    ]}
                ],
                keyFeatures: ['Campaign Management', 'Donation Processing', 'Impact Tracking', 'Donor Engagement'],
                userRoles: [
                    { name: 'Admin', description: 'Complete system access', permissions: ['Full Access', 'Financial Data', 'User Management'] },
                    { name: 'Support', description: 'Customer service access', permissions: ['Customer Support', 'Order Management'] }
                ]
            }
        };

        // STRIPE PRODUCTS ANALYZER (EXACT SAME AS ORIGINAL)
        const STRIPE_PRODUCTS = {
            payments: {
                name: 'Payments',
                description: 'Accept payments online and in person',
                priority: 'essential',
                dataObjects: ['charges', 'payment_intents', 'payment_methods'],
                triggers: ['payment', 'transaction', 'checkout', 'e-commerce', 'retail']
            },
            billing: {
                name: 'Billing',
                description: 'Subscription and recurring billing management',
                priority: 'essential',
                dataObjects: ['subscriptions', 'invoices', 'customers', 'plans', 'subscription_items'],
                triggers: ['subscription', 'recurring', 'membership', 'saas', 'billing']
            },
            connect: {
                name: 'Connect',
                description: 'Platform payments and marketplace functionality',
                priority: 'essential',
                dataObjects: ['accounts', 'transfers', 'application_fees', 'charges'],
                triggers: ['marketplace', 'platform', 'payouts', 'commission', 'multi-party', 'connect']
            },
            tax: {
                name: 'Tax',
                description: 'Automated tax calculation and reporting',
                priority: 'recommended',
                dataObjects: ['tax_rates', 'tax_transactions', 'tax_calculations'],
                triggers: ['e-commerce', 'retail', 'physical goods', 'tax compliance', 'sales tax']
            },
            radar: {
                name: 'Radar',
                description: 'Machine learning fraud prevention',
                priority: 'recommended',
                dataObjects: ['disputes', 'review_events', 'early_fraud_warnings'],
                triggers: ['high-value', 'fraud risk', 'chargebacks', 'marketplace', 'b2b', 'security']
            }
        };

        // Analyze Stripe products for a persona
        function analyzeStripeProducts(persona) {
            const recommendedProducts = [];
            
            // Always include Payments as essential
            recommendedProducts.push({
                name: STRIPE_PRODUCTS.payments.name,
                description: STRIPE_PRODUCTS.payments.description,
                priority: 'essential',
                dataObjects: STRIPE_PRODUCTS.payments.dataObjects
            });
            
            // Persona-specific analysis
            if (persona.name === 'Checkout e-commerce') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.tax.name,
                    description: STRIPE_PRODUCTS.tax.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.tax.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.radar.name,
                    description: STRIPE_PRODUCTS.radar.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.radar.dataObjects
                });
            } else if (persona.name === 'B2B SaaS subscriptions') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.billing.name,
                    description: STRIPE_PRODUCTS.billing.description,
                    priority: 'essential',
                    dataObjects: STRIPE_PRODUCTS.billing.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.radar.name,
                    description: STRIPE_PRODUCTS.radar.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.radar.dataObjects
                });
            } else if (persona.name === 'Food delivery platform') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.connect.name,
                    description: STRIPE_PRODUCTS.connect.description,
                    priority: 'essential',
                    dataObjects: STRIPE_PRODUCTS.connect.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.tax.name,
                    description: STRIPE_PRODUCTS.tax.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.tax.dataObjects
                });
            } else if (persona.name === 'Consumer fitness app') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.billing.name,
                    description: STRIPE_PRODUCTS.billing.description,
                    priority: 'essential',
                    dataObjects: STRIPE_PRODUCTS.billing.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.tax.name,
                    description: STRIPE_PRODUCTS.tax.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.tax.dataObjects
                });
            } else if (persona.name === 'B2B invoicing') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.billing.name,
                    description: STRIPE_PRODUCTS.billing.description,
                    priority: 'essential',
                    dataObjects: STRIPE_PRODUCTS.billing.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.tax.name,
                    description: STRIPE_PRODUCTS.tax.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.tax.dataObjects
                });
            } else if (persona.name === 'Property management platform') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.billing.name,
                    description: STRIPE_PRODUCTS.billing.description,
                    priority: 'essential',
                    dataObjects: STRIPE_PRODUCTS.billing.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.tax.name,
                    description: STRIPE_PRODUCTS.tax.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.tax.dataObjects
                });
            } else if (persona.name === 'Creator platform') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.connect.name,
                    description: STRIPE_PRODUCTS.connect.description,
                    priority: 'essential',
                    dataObjects: STRIPE_PRODUCTS.connect.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.billing.name,
                    description: STRIPE_PRODUCTS.billing.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.billing.dataObjects
                });
            } else if (persona.name === 'Donation marketplace') {
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.connect.name,
                    description: STRIPE_PRODUCTS.connect.description,
                    priority: 'essential',
                    dataObjects: STRIPE_PRODUCTS.connect.dataObjects
                });
                recommendedProducts.push({
                    name: STRIPE_PRODUCTS.tax.name,
                    description: STRIPE_PRODUCTS.tax.description,
                    priority: 'recommended',
                    dataObjects: STRIPE_PRODUCTS.tax.dataObjects
                });
            }
            
            return recommendedProducts;
        }

        // Seeded random function for deterministic generation
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Generate realistic Stripe-style IDs
        function generateStripeId(prefix, seed) {
            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = prefix;
            for (let i = 0; i < 20; i++) {
                id += chars[Math.floor(seededRandom(seed + i) * chars.length)];
            }
            return id;
        }

        // Generate realistic timestamps
        function generateRealisticTimestamp(seed, daysBack) {
            const now = Math.floor(Date.now() / 1000);
            const secondsBack = Math.floor(seededRandom(seed) * daysBack * 24 * 60 * 60);
            return now - secondsBack;
        }

        // Store counts globally to ensure consistency across all surfaces
        let globalCounts = null;
        
        // Get realistic counts based on business type and stage (EXACT SAME LOGIC AS NEXT-APP)
        function getRealisticCounts(businessType, stage) {
            // If we already have counts for this business type and stage, return them
            if (globalCounts && globalCounts.businessType === businessType && globalCounts.stage === stage) {
                return globalCounts.counts;
            }
            const baseCounts = {
                'checkout-ecommerce': { customers: 25000, subscriptions: 0, charges: 150000, invoices: 25000 },
                'b2b-saas-subscriptions': { customers: 5000, subscriptions: 12000, charges: 25000, invoices: 5000 },
                'food-delivery-platform': { customers: 50000, subscriptions: 0, charges: 300000, invoices: 50000 },
                'consumer-fitness-app': { customers: 15000, subscriptions: 25000, charges: 75000, invoices: 15000 },
                'b2b-invoicing': { customers: 3000, subscriptions: 0, charges: 15000, invoices: 12000 },
                'property-management-platform': { customers: 2000, subscriptions: 0, charges: 10000, invoices: 8000 },
                'creator-platform': { customers: 30000, subscriptions: 0, charges: 180000, invoices: 30000 },
                'donation-marketplace': { customers: 20000, subscriptions: 0, charges: 120000, invoices: 20000 }
            };
            
            const businessCounts = baseCounts[businessType.toLowerCase()] || baseCounts['b2b-saas-subscriptions'];
            
            const stageMultipliers = {
                early: 0.1,
                growth: 1.0,
                enterprise: 20.0
            };
            
            const stageMultiplier = stageMultipliers[stage] || 1.0;
            
            // Use seeded random for deterministic results
            const seed = businessType.charCodeAt(0) + stage.charCodeAt(0);
            const seededRandom = (offset) => {
                const x = Math.sin(seed + offset) * 10000;
                return x - Math.floor(x);
            };
            
            const enterpriseVariation = stage === 'enterprise' ? (0.7 + seededRandom(1) * 0.6) : 1.0;
            
            const counts = {
                customers: Math.floor(businessCounts.customers * stageMultiplier * (0.8 + seededRandom(2) * 0.4) * enterpriseVariation),
                subscriptions: Math.floor(businessCounts.subscriptions * stageMultiplier * (0.8 + seededRandom(3) * 0.4) * enterpriseVariation),
                charges: Math.floor(businessCounts.charges * stageMultiplier * (0.8 + seededRandom(4) * 0.4) * enterpriseVariation),
                invoices: Math.floor(businessCounts.invoices * stageMultiplier * (0.8 + seededRandom(5) * 0.4) * enterpriseVariation),
                plans: 5
            };
            
            // Store the counts globally
            globalCounts = {
                businessType: businessType,
                stage: stage,
                counts: counts
            };
            
            return counts;
        }

        // Generate sample data objects (like the original next-app)
        function generateSampleData(businessType, stage) {
            const counts = getRealisticCounts(businessType, stage);
            const data = {};
            
            // Generate customers
            if (counts.customers > 0) {
                data.customers = Array.from({length: Math.min(3, counts.customers)}, (_, i) => ({
                    id: generateStripeId('cus_', i),
                    name: generateRealisticName(i, businessType),
                    email: generateRealisticEmail(i, businessType),
                    created: generateRealisticTimestamp(i, 365),
                    status: 'active'
                }));
            }
            
            // Generate charges
            if (counts.charges > 0) {
                data.charges = Array.from({length: Math.min(3, counts.charges)}, (_, i) => ({
                    id: generateStripeId('ch_', i),
                    amount: Math.floor(seededRandom(i) * 10000) + 1000,
                    status: seededRandom(i + 1) < 0.9 ? 'succeeded' : 'failed',
                    created: generateRealisticTimestamp(i + 2, 90),
                    currency: 'usd'
                }));
            }
            
            // Generate subscriptions
            if (counts.subscriptions > 0) {
                data.subscriptions = Array.from({length: Math.min(3, counts.subscriptions)}, (_, i) => ({
                    id: generateStripeId('sub_', i),
                    status: seededRandom(i + 3) < 0.8 ? 'active' : 'canceled',
                    created: generateRealisticTimestamp(i + 4, 180),
                    amount: Math.floor(seededRandom(i + 5) * 5000) + 1000,
                    interval: 'month'
                }));
            }
            
            // Generate invoices
            if (counts.invoices > 0) {
                data.invoices = Array.from({length: Math.min(3, counts.invoices)}, (_, i) => ({
                    id: generateStripeId('in_', i),
                    amount_due: Math.floor(seededRandom(i + 6) * 8000) + 2000,
                    status: seededRandom(i + 7) < 0.85 ? 'paid' : 'open',
                    created: generateRealisticTimestamp(i + 8, 60),
                    currency: 'usd'
                }));
            }
            
            return data;
        }

        // METRIC_AVAILABILITY system (EXACT SAME AS ORIGINAL NEXT-APP)
        const METRIC_AVAILABILITY = {
            'checkout-ecommerce': {
                subscriptions: false,
                radar: false,
                disputes: true,
                refunds: true,
                authentication: true
            },
            'b2b-saas-subscriptions': {
                subscriptions: true,
                radar: true,
                disputes: true,
                refunds: true,
                authentication: true
            },
            'food-delivery-platform': {
                subscriptions: false,
                radar: true,
                disputes: true,
                refunds: true,
                authentication: false
            },
            'consumer-fitness-app': {
                subscriptions: true,
                radar: false,
                disputes: true,
                refunds: true,
                authentication: false
            },
            'b2b-invoicing': {
                subscriptions: false,
                radar: false,
                disputes: false,
                refunds: true,
                authentication: false
            },
            'property-management-platform': {
                subscriptions: false,
                radar: true,
                disputes: true,
                refunds: true,
                authentication: true
            },
            'creator-platform': {
                subscriptions: false,
                radar: false,
                disputes: true,
                refunds: true,
                authentication: false
            },
            'donation-marketplace': {
                subscriptions: false,
                radar: false,
                disputes: true,
                refunds: true,
                authentication: false
            }
        };

        // Generate comprehensive metrics with persona-based filtering (EXACT SAME AS ORIGINAL NEXT-APP)
        function generateComprehensiveMetrics(stripeData, businessType, stage) {
            const { customers, charges, subscriptions, invoices } = stripeData;
            const availability = METRIC_AVAILABILITY[businessType.toLowerCase()] || METRIC_AVAILABILITY['b2b-saas-subscriptions'];
            
            const allMetrics = [
                // Core Payment Metrics (All Personas)
                { name: 'Gross Payment Volume', available: true },
                { name: 'Payment Success Rate', available: true },
                { name: 'Successful Payments', available: true },
                { name: 'Failed Card Payments - Failed Volume', available: true },
                { name: 'Failed Card Payments - Failed Count', available: true },
                { name: 'Failed Card Payments - Failure Rate', available: true },
                { name: 'Average Order Value', available: true },
                { name: 'Conversion Rate', available: true },
                { name: 'Payment Method Distribution', available: true },
                { name: 'Geographic Distribution', available: true },
                { name: 'Processing Fees', available: true },
                { name: 'Net Revenue', available: true },
                { name: 'One-time Revenue', available: true },
                
                // Subscription Metrics (B2B SaaS, Consumer Fitness)
                { name: 'Monthly Recurring Revenue', available: availability.subscriptions },
                { name: 'Annual Recurring Revenue', available: availability.subscriptions },
                { name: 'Active Subscribers', available: availability.subscriptions },
                { name: 'Subscription Revenue', available: availability.subscriptions },
                { name: 'Churn Rate', available: availability.subscriptions },
                { name: 'Customer Retention Rate', available: availability.subscriptions },
                { name: 'Average Revenue Per User (ARPU)', available: availability.subscriptions },
                { name: 'Subscription Growth Rate', available: availability.subscriptions },
                { name: 'Trial Conversion Rate', available: availability.subscriptions },
                { name: 'Upgrade/Downgrade Rates', available: availability.subscriptions },
                { name: 'Billing Cycle Distribution', available: availability.subscriptions },
                
                // Customer Metrics (All Personas)
                { name: 'Customer Lifetime Value', available: true },
                { name: 'Customer Acquisition Cost', available: true },
                { name: 'Revenue per Customer', available: true },
                { name: 'Customer Growth Rate', available: true },
                { name: 'Customer Engagement Score', available: true },
                
                // Risk & Dispute Metrics (Persona-Specific)
                { name: 'Dispute Rate', available: availability.disputes },
                { name: 'Chargeback Rate', available: availability.disputes },
                { name: 'Dispute Resolution Rate', available: availability.disputes },
                { name: 'Refund Rate', available: availability.refunds },
                { name: 'Radar Risk Score', available: availability.radar },
                { name: 'Fraud Detection Rate', available: availability.radar },
                { name: 'Risk Assessment Score', available: availability.radar },
                { name: 'Fraud Prevention Effectiveness', available: availability.radar },
                { name: 'Authentication Success Rate', available: availability.authentication },
                
                // Financial Metrics (All Personas)
                { name: 'Tax Collected', available: true },
                { name: 'Currency Distribution', available: true },
                { name: 'Exchange Rate Impact', available: true },
                { name: 'Fee Structure Analysis', available: true },
                { name: 'Profit Margin Analysis', available: true },
                { name: 'Cash Flow Trends', available: true },
                { name: 'Revenue Recognition', available: true },
                
                // Operational Metrics (All Personas)
                { name: 'API Usage Metrics', available: true },
                { name: 'Webhook Delivery Success Rate', available: true },
                { name: 'System Uptime', available: true },
                { name: 'Response Time Metrics', available: true },
                { name: 'Error Rate Analysis', available: true },
                { name: 'Performance Monitoring', available: true },
                
                // Time-based Analysis (All Personas)
                { name: 'Time-based Trends', available: true },
                { name: 'Seasonal Patterns', available: true },
                { name: 'Peak Hours Analysis', available: true },
                { name: 'Weekly Patterns', available: true },
                { name: 'Monthly Growth Trends', available: true }
            ];
            
            // Filter to only available metrics
            return allMetrics.filter(metric => metric.available).map(metric => metric.name);
        }

        // Get included metrics (EXACT SAME AS ORIGINAL NEXT-APP)
        function getIncludedMetrics(dataset, businessType, stage) {
            const metrics = generateComprehensiveMetrics(dataset, businessType, stage);
            return metrics; // Return all available metrics, not just first 12
        }

        // Update Stripe products display (PERSONA-BASED)
        function updateStripeProducts(businessType, stage) {
            console.log('updateStripeProducts called');
            const persona = PREDEFINED_PERSONAS[businessType];
            console.log('Persona found:', persona);
            if (!persona) return;
            
            const recommendedProducts = analyzeStripeProducts(persona);
            console.log('Recommended products:', recommendedProducts);
            const container = document.getElementById('stripe-products-section');
            
            container.innerHTML = `
                <div class="mb-8">
                    <h3 class="text-xl font-semibold text-gray-900 mb-4">Stripe products</h3>
                    <div class="space-y-3">
                        ${recommendedProducts.map(product => `
                            <div class="border-l-4 pl-4 border-orange">
                                <div class="font-medium text-gray-900">${product.name}</div>
                                <div class="text-sm text-gray-600 mb-1">${product.description}</div>
                                <div class="flex flex-wrap gap-1 mt-1">
                                    <span class="px-2 py-1 bg-gray-100 text-gray-800 rounded-xl text-xs">Priority: ${product.priority}</span>
                                    ${product.dataObjects.map(obj => `
                                        <span class="px-2 py-1 bg-gray-100 text-gray-800 rounded-xl text-xs">${obj}</span>
                                    `).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }


        // Generate realistic names and emails based on persona
        function generateRealisticName(seed, businessType) {
            // Comprehensive name generators with hundreds of options
            const firstNames = ['James', 'Mary', 'Robert', 'Patricia', 'John', 'Jennifer', 'Michael', 'Linda', 'David', 'Elizabeth', 'William', 'Barbara', 'Richard', 'Susan', 'Joseph', 'Jessica', 'Thomas', 'Sarah', 'Christopher', 'Karen', 'Charles', 'Nancy', 'Daniel', 'Lisa', 'Matthew', 'Betty', 'Anthony', 'Helen', 'Mark', 'Sandra', 'Donald', 'Donna', 'Steven', 'Carol', 'Paul', 'Ruth', 'Andrew', 'Sharon', 'Joshua', 'Michelle', 'Kenneth', 'Laura', 'Kevin', 'Sarah', 'Brian', 'Kimberly', 'George', 'Deborah', 'Timothy', 'Dorothy', 'Ronald', 'Lisa', 'Jason', 'Nancy', 'Edward', 'Karen', 'Jeffrey', 'Betty', 'Ryan', 'Helen', 'Jacob', 'Sandra', 'Gary', 'Donna', 'Nicholas', 'Carol', 'Eric', 'Ruth', 'Jonathan', 'Sharon', 'Stephen', 'Michelle', 'Larry', 'Laura', 'Justin', 'Sarah', 'Scott', 'Kimberly', 'Brandon', 'Deborah', 'Benjamin', 'Dorothy', 'Samuel', 'Amy', 'Gregory', 'Angela', 'Alexander', 'Ashley', 'Patrick', 'Brenda', 'Frank', 'Emma', 'Raymond', 'Olivia', 'Jack', 'Cynthia', 'Dennis', 'Marie', 'Jerry', 'Janet', 'Tyler', 'Catherine', 'Aaron', 'Frances', 'Jose', 'Christine', 'Henry', 'Samantha', 'Adam', 'Debra', 'Douglas', 'Rachel', 'Nathan', 'Carolyn', 'Peter', 'Janet', 'Zachary', 'Virginia', 'Kyle', 'Maria', 'Noah', 'Heather', 'Alan', 'Diane', 'Ethan', 'Julie', 'Jeremy', 'Joyce', 'Carl', 'Victoria', 'Harold', 'Kelly', 'Arthur', 'Christina', 'Lawrence', 'Joan', 'Sean', 'Evelyn', 'Christian', 'Lauren', 'Albert', 'Judith', 'Wayne', 'Megan', 'Mason', 'Cheryl', 'Ralph', 'Andrea', 'Roy', 'Hannah', 'Eugene', 'Jacqueline', 'Louis', 'Martha', 'Philip', 'Gloria', 'Bobby', 'Teresa', 'Johnny', 'Sara', 'Mason', 'Janice'];
            const lastNames = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis', 'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson', 'Anderson', 'Thomas', 'Taylor', 'Moore', 'Jackson', 'Martin', 'Lee', 'Perez', 'Thompson', 'White', 'Harris', 'Sanchez', 'Clark', 'Ramirez', 'Lewis', 'Robinson', 'Walker', 'Young', 'Allen', 'King', 'Wright', 'Scott', 'Torres', 'Nguyen', 'Hill', 'Flores', 'Green', 'Adams', 'Nelson', 'Baker', 'Hall', 'Rivera', 'Campbell', 'Mitchell', 'Carter', 'Roberts', 'Gomez', 'Phillips', 'Evans', 'Turner', 'Diaz', 'Parker', 'Cruz', 'Edwards', 'Collins', 'Reyes', 'Stewart', 'Morris', 'Morales', 'Murphy', 'Cook', 'Rogers', 'Gutierrez', 'Ortiz', 'Morgan', 'Cooper', 'Peterson', 'Bailey', 'Reed', 'Kelly', 'Howard', 'Ramos', 'Kim', 'Cox', 'Ward', 'Richardson', 'Watson', 'Brooks', 'Chavez', 'Wood', 'James', 'Bennett', 'Gray', 'Mendoza', 'Ruiz', 'Hughes', 'Price', 'Alvarez', 'Castillo', 'Sanders', 'Patel', 'Myers', 'Long', 'Ross', 'Foster', 'Jimenez'];
            const companyPrefixes = ['Tech', 'Data', 'Cloud', 'Digital', 'Smart', 'Global', 'Innovative', 'Advanced', 'Premier', 'Elite', 'Pro', 'Next', 'Future', 'Modern', 'Dynamic', 'Strategic', 'Optimal', 'Peak', 'Prime', 'Core', 'Apex', 'Vertex', 'Matrix', 'Quantum', 'Synergy', 'Fusion', 'Nexus', 'Catalyst', 'Pinnacle', 'Summit'];
            const companySuffixes = ['Solutions', 'Systems', 'Technologies', 'Innovations', 'Enterprises', 'Corporation', 'Inc', 'LLC', 'Group', 'Partners', 'Associates', 'Consulting', 'Services', 'Labs', 'Works', 'Hub', 'Studio', 'Agency', 'Dynamics', 'Analytics', 'Platforms', 'Networks', 'Interactive', 'Digital', 'Media', 'Creative', 'Design', 'Development', 'Engineering', 'Research'];
            
            if (businessType === 'checkout-ecommerce' || businessType === 'food-delivery-platform' || businessType === 'consumer-fitness-app' || businessType === 'donation-marketplace') {
                // Consumer names
                const firstName = firstNames[Math.abs(seed * 17) % firstNames.length];
                const lastName = lastNames[Math.abs(seed * 23 + 7) % lastNames.length];
                return `${firstName} ${lastName}`;
            } else {
                // Business names
                const prefix = companyPrefixes[Math.abs(seed * 13) % companyPrefixes.length];
                const suffix = companySuffixes[Math.abs(seed * 19 + 11) % companySuffixes.length];
                return `${prefix} ${suffix}`;
            }
        }
        
        function generateRealisticEmail(seed, businessType) {
            const consumerDomains = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'aol.com', 'icloud.com', 'protonmail.com', 'mail.com', 'live.com', 'msn.com', 'comcast.net', 'verizon.net', 'att.net', 'cox.net', 'charter.net', 'earthlink.net', 'juno.com', 'netzero.net', 'sbcglobal.net', 'bellsouth.net'];
            const businessDomains = ['company.com', 'corp.com', 'business.net', 'enterprise.org', 'solutions.io', 'tech.co', 'systems.biz', 'group.net', 'inc.com', 'llc.org', 'consulting.com', 'services.net', 'partners.co', 'associates.biz', 'innovations.io', 'technologies.com', 'digital.net', 'analytics.co', 'platforms.io', 'networks.com'];
            
            const domains = (businessType === 'checkout-ecommerce' || businessType === 'food-delivery-platform' || businessType === 'consumer-fitness-app' || businessType === 'donation-marketplace') 
                ? consumerDomains 
                : businessDomains;
                
            const domain = domains[Math.abs(seed * 31) % domains.length];
            const name = generateRealisticName(seed, businessType).toLowerCase().replace(/[^a-z]/g, '');
            const emailPrefix = name.length > 15 ? name.substring(0, 15) : name;
            return `${emailPrefix}${Math.abs(seed) % 1000}@${domain}`;
        }
        // Generate comprehensive dataset with all Stripe objects
        function generateComprehensiveDataset(businessType, stage, counts, patterns) {
            const dataset = {
                customers: [],
                charges: [],
                subscriptions: [],
                invoices: [],
                plans: [],
                payment_methods: [],
                payment_intents: [],
                refunds: [],
                disputes: [],
                products: [],
                prices: [],
                coupons: [],
                balance_transactions: [],
                events: [],
                setup_intents: [],
                _metadata: {
                    generatedAt: new Date().toISOString(),
                    businessType: businessType,
                    stage: stage,
                    counts: {
                        customers: counts.customers,
                        charges: counts.charges,
                        subscriptions: counts.subscriptions,
                        invoices: counts.invoices,
                        plans: counts.plans,
                        payment_methods: Math.floor(counts.customers * 1.2),
                        payment_intents: counts.charges,
                        refunds: Math.floor(counts.charges * 0.1),
                        disputes: Math.floor(counts.charges * 0.05),
                        products: counts.plans,
                        prices: counts.plans,
                        coupons: Math.floor(counts.plans * 0.5),
                        balance_transactions: Math.floor(counts.charges * 1.1),
                        events: Math.floor(counts.charges * 0.8),
                        setup_intents: Math.floor(counts.customers * 0.3)
                    },
                    source: 'synthkit-comprehensive'
                }
            };

            // Generate customers
            for (let i = 0; i < counts.customers; i++) {
                const seed = i * 1000;
                dataset.customers.push({
                    id: generateStripeId('cus_', seed),
                    name: generateRealisticName(seed, businessType),
                    email: generateRealisticEmail(seed, businessType),
                    created: generateRealisticTimestamp(seed, 365),
                    status: 'active'
                });
            }

            // Generate charges
            for (let i = 0; i < counts.charges; i++) {
                const seed = i * 2000;
                const amountRange = patterns.chargeAmountMax - patterns.chargeAmountMin;
                dataset.charges.push({
                    id: generateStripeId('ch_', seed),
                    amount: Math.floor(seededRandom(seed) * amountRange) + patterns.chargeAmountMin,
                    currency: 'usd',
                    status: seededRandom(seed + 1) < patterns.successRate ? 'succeeded' : 'failed',
                    created: generateRealisticTimestamp(seed + 2, 90),
                    customer: generateStripeId('cus_', Math.floor(seededRandom(seed + 3) * counts.customers))
                });
            }

            // Generate subscriptions
            for (let i = 0; i < counts.subscriptions; i++) {
                const seed = i * 3000;
                const subAmountRange = patterns.subscriptionAmountMax - patterns.subscriptionAmountMin;
                const amount = patterns.subscriptionAmountMax > 0 
                    ? Math.floor(seededRandom(seed + 2) * subAmountRange) + patterns.subscriptionAmountMin
                    : Math.floor(seededRandom(seed + 2) * 5000) + 1000;
                dataset.subscriptions.push({
                    id: generateStripeId('sub_', seed),
                    customer: generateStripeId('cus_', Math.floor(seededRandom(seed) * counts.customers)),
                    status: seededRandom(seed + 1) < 0.8 ? 'active' : 'canceled',
                    amount: amount,
                    interval: 'month',
                    created: generateRealisticTimestamp(seed + 3, 180)
                });
            }

            // Generate invoices
            for (let i = 0; i < counts.invoices; i++) {
                const seed = i * 4000;
                dataset.invoices.push({
                    id: generateStripeId('in_', seed),
                    customer: generateStripeId('cus_', Math.floor(seededRandom(seed) * counts.customers)),
                    amount_due: Math.floor(seededRandom(seed + 1) * 8000) + 2000,
                    currency: 'usd',
                    status: seededRandom(seed + 2) < 0.85 ? 'paid' : 'open',
                    created: generateRealisticTimestamp(seed + 3, 60)
                });
            }

            // Generate plans
            for (let i = 0; i < counts.plans; i++) {
                const seed = i * 5000;
                const planNames = ['Basic', 'Professional', 'Business', 'Enterprise', 'Team'];
                dataset.plans.push({
                    id: generateStripeId('plan_', seed),
                    name: planNames[i % planNames.length],
                    amount: Math.floor(seededRandom(seed) * 5000) + 1000,
                    interval: seededRandom(seed + 1) < 0.8 ? 'month' : 'year',
                    currency: 'usd',
                    created: generateRealisticTimestamp(seed + 2, 365)
                });
            }

            // Generate payment methods
            for (let i = 0; i < Math.floor(counts.customers * 1.2); i++) {
                const seed = i * 6000;
                const cardBrands = ['visa', 'mastercard', 'amex', 'discover'];
                dataset.payment_methods.push({
                    id: generateStripeId('pm_', seed),
                    type: 'card',
                    card: {
                        brand: cardBrands[Math.abs(seed) % cardBrands.length],
                        last4: String(Math.abs(seed) % 10000).padStart(4, '0'),
                        exp_month: (Math.abs(seed) % 12) + 1,
                        exp_year: 2025 + (Math.abs(seed) % 5)
                    },
                    customer: generateStripeId('cus_', Math.floor(seededRandom(seed) * counts.customers)),
                    created: generateRealisticTimestamp(seed + 1, 365)
                });
            }

            // Generate other Stripe objects...
            // (Similar pattern for payment_intents, refunds, disputes, products, prices, coupons, balance_transactions, events, setup_intents)

            // Generate comprehensive metrics
            const metrics = generateComprehensiveMetrics(dataset, businessType, stage);
            dataset.metrics = metrics.map(metricName => ({
                name: metricName,
                value: calculateMetricValue(metricName, dataset, businessType, stage),
                unit: getMetricUnit(metricName),
                description: getMetricDescription(metricName)
            }));

            return dataset;
        }

        // Calculate metric values based on dataset
        function calculateMetricValue(metricName, dataset, businessType, stage) {
            const { customers, charges, subscriptions, invoices } = dataset;
            
            switch (metricName) {
                case 'Gross Payment Volume':
                    return charges.filter(c => c.status === 'succeeded').reduce((sum, c) => sum + c.amount, 0);
                case 'Payment Success Rate':
                    const totalCharges = charges.length;
                    const successfulChargesCount = charges.filter(c => c.status === 'succeeded').length;
                    return totalCharges > 0 ? (successfulChargesCount / totalCharges * 100).toFixed(2) : 0;
                case 'Monthly Recurring Revenue':
                    return subscriptions.filter(s => s.status === 'active').reduce((sum, s) => sum + s.amount, 0);
                case 'Customer Lifetime Value':
                    const avgChargeValue = charges.filter(c => c.status === 'succeeded').reduce((sum, c) => sum + c.amount, 0) / Math.max(charges.length, 1);
                    return Math.floor(avgChargeValue * 12); // Annual estimate
                case 'Average Order Value':
                    const successfulCharges = charges.filter(c => c.status === 'succeeded');
                    return successfulCharges.length > 0 ? Math.floor(successfulCharges.reduce((sum, c) => sum + c.amount, 0) / successfulCharges.length) : 0;
                case 'Active Subscribers':
                    return subscriptions.filter(s => s.status === 'active').length;
                case 'Refund Rate':
                    const refunds = dataset.refunds || [];
                    return charges.length > 0 ? ((refunds.length / charges.length) * 100).toFixed(2) : 0;
                case 'Dispute Rate':
                    const disputes = dataset.disputes || [];
                    return charges.length > 0 ? ((disputes.length / charges.length) * 100).toFixed(2) : 0;
                default:
                    return Math.floor(Math.random() * 10000) + 1000; // Default realistic value
            }
        }

        // Get metric unit
        function getMetricUnit(metricName) {
            const units = {
                'Gross Payment Volume': 'cents',
                'Payment Success Rate': '%',
                'Monthly Recurring Revenue': 'cents',
                'Customer Lifetime Value': 'cents',
                'Average Order Value': 'cents',
                'Active Subscribers': 'count',
                'Refund Rate': '%',
                'Dispute Rate': '%',
                'Conversion Rate': '%',
                'Churn Rate': '%',
                'Customer Acquisition Cost': 'cents'
            };
            return units[metricName] || 'count';
        }

        // Get metric description
        function getMetricDescription(metricName) {
            const descriptions = {
                'Gross Payment Volume': 'Total value of all successful payments',
                'Payment Success Rate': 'Percentage of payments that succeeded',
                'Monthly Recurring Revenue': 'Recurring revenue from active subscriptions',
                'Customer Lifetime Value': 'Estimated total value of a customer over their lifetime',
                'Average Order Value': 'Average amount per successful transaction',
                'Active Subscribers': 'Number of customers with active subscriptions',
                'Refund Rate': 'Percentage of transactions that were refunded',
                'Dispute Rate': 'Percentage of transactions that resulted in disputes',
                'Conversion Rate': 'Percentage of visitors who completed a purchase',
                'Churn Rate': 'Percentage of subscribers who canceled their subscription',
                'Customer Acquisition Cost': 'Average cost to acquire a new customer'
            };
            return descriptions[metricName] || 'Business metric';
        }

        // Generate persona-specific amounts and patterns
        function getPersonaPatterns(businessType) {
            const patterns = {
                'checkout-ecommerce': {
                    chargeAmountMin: 1000, // $10
                    chargeAmountMax: 20000, // $200
                    subscriptionAmountMin: 0,
                    subscriptionAmountMax: 0,
                    successRate: 0.95,
                    refundRate: 0.08
                },
                'b2b-saas-subscriptions': {
                    chargeAmountMin: 10000, // $100
                    chargeAmountMax: 200000, // $2000
                    subscriptionAmountMin: 5000, // $50
                    subscriptionAmountMax: 50000, // $500
                    successRate: 0.98,
                    refundRate: 0.02
                },
                'food-delivery-platform': {
                    chargeAmountMin: 1500, // $15
                    chargeAmountMax: 5000, // $50
                    subscriptionAmountMin: 0,
                    subscriptionAmountMax: 0,
                    successRate: 0.92,
                    refundRate: 0.12
                },
                'consumer-fitness-app': {
                    chargeAmountMin: 999, // $9.99
                    chargeAmountMax: 9999, // $99.99
                    subscriptionAmountMin: 999, // $9.99
                    subscriptionAmountMax: 4999, // $49.99
                    successRate: 0.94,
                    refundRate: 0.06
                },
                'b2b-invoicing': {
                    chargeAmountMin: 5000, // $50
                    chargeAmountMax: 100000, // $1000
                    subscriptionAmountMin: 0,
                    subscriptionAmountMax: 0,
                    successRate: 0.96,
                    refundRate: 0.03
                },
                'property-management-platform': {
                    chargeAmountMin: 50000, // $500
                    chargeAmountMax: 500000, // $5000
                    subscriptionAmountMin: 0,
                    subscriptionAmountMax: 0,
                    successRate: 0.97,
                    refundRate: 0.04
                },
                'creator-platform': {
                    chargeAmountMin: 500, // $5
                    chargeAmountMax: 10000, // $100
                    subscriptionAmountMin: 0,
                    subscriptionAmountMax: 0,
                    successRate: 0.93,
                    refundRate: 0.07
                },
                'donation-marketplace': {
                    chargeAmountMin: 1000, // $10
                    chargeAmountMax: 50000, // $500
                    subscriptionAmountMin: 0,
                    subscriptionAmountMax: 0,
                    successRate: 0.96,
                    refundRate: 0.05
                }
            };
            return patterns[businessType] || patterns['b2b-saas-subscriptions'];
        }

        // Update dataset structure display (EXACT SAME AS ORIGINAL NEXT-APP)
        function updateDatasetStructure(businessType, stage) {
            const counts = getRealisticCounts(businessType, stage);
            const patterns = getPersonaPatterns(businessType);
            const container = document.getElementById('dataset-structure-section');
            
            // Generate realistic Stripe data structure (sample only for display)
            const sampleSize = 3; // Only generate 3 examples of each type
            const stripeData = {
                customers: Array.from({length: Math.min(sampleSize, counts.customers)}, (_, i) => {
                    const seed = i * 1000;
                    return {
                        id: generateStripeId('cus_', seed),
                        name: generateRealisticName(seed, businessType),
                        email: generateRealisticEmail(seed, businessType),
                        created: generateRealisticTimestamp(seed, 365),
                        status: 'active'
                    };
                }),
                charges: Array.from({length: Math.min(sampleSize, counts.charges)}, (_, i) => {
                    const seed = i * 2000;
                    const amountRange = patterns.chargeAmountMax - patterns.chargeAmountMin;
                    return {
                        id: generateStripeId('ch_', seed),
                        amount: Math.floor(seededRandom(seed) * amountRange) + patterns.chargeAmountMin,
                        currency: 'usd',
                        status: seededRandom(seed + 1) < patterns.successRate ? 'succeeded' : 'failed',
                        created: generateRealisticTimestamp(seed + 2, 90),
                        customer: generateStripeId('cus_', Math.floor(seededRandom(seed + 3) * counts.customers))
                    };
                }),
                subscriptions: Array.from({length: Math.min(sampleSize, counts.subscriptions)}, (_, i) => {
                    const seed = i * 3000;
                    const subAmountRange = patterns.subscriptionAmountMax - patterns.subscriptionAmountMin;
                    const amount = patterns.subscriptionAmountMax > 0 
                        ? Math.floor(seededRandom(seed + 2) * subAmountRange) + patterns.subscriptionAmountMin
                        : Math.floor(seededRandom(seed + 2) * 5000) + 1000;
                    return {
                        id: generateStripeId('sub_', seed),
                        customer: generateStripeId('cus_', Math.floor(seededRandom(seed) * counts.customers)),
                        status: seededRandom(seed + 1) < 0.8 ? 'active' : 'canceled',
                        amount: amount,
                        interval: 'month',
                        created: generateRealisticTimestamp(seed + 3, 180)
                    };
                }),
                invoices: Array.from({length: Math.min(sampleSize, counts.invoices)}, (_, i) => {
                    const seed = i * 4000;
                    return {
                        id: generateStripeId('in_', seed),
                        customer: generateStripeId('cus_', Math.floor(seededRandom(seed) * counts.customers)),
                        amount_due: Math.floor(seededRandom(seed + 1) * 8000) + 2000,
                        currency: 'usd',
                        status: seededRandom(seed + 2) < 0.85 ? 'paid' : 'open',
                        created: generateRealisticTimestamp(seed + 3, 60)
                    };
                }),
                plans: Array.from({length: Math.min(sampleSize, counts.plans)}, (_, i) => {
                    const seed = i * 5000;
                    const planNames = ['Basic', 'Professional', 'Business', 'Enterprise', 'Team'];
                    return {
                        id: generateStripeId('plan_', seed),
                        name: planNames[i % planNames.length],
                        amount: Math.floor(seededRandom(seed) * 5000) + 1000,
                        interval: seededRandom(seed + 1) < 0.8 ? 'month' : 'year',
                        currency: 'usd',
                        created: generateRealisticTimestamp(seed + 2, 365)
                    };
                }),
                payment_methods: Array.from({length: Math.min(sampleSize, Math.floor(counts.customers * 1.2))}, (_, i) => {
                    const seed = i * 6000;
                    const cardBrands = ['visa', 'mastercard', 'amex', 'discover'];
                    return {
                        id: generateStripeId('pm_', seed),
                        type: 'card',
                        card: {
                            brand: cardBrands[Math.abs(seed) % cardBrands.length],
                            last4: String(Math.abs(seed) % 10000).padStart(4, '0'),
                            exp_month: (Math.abs(seed) % 12) + 1,
                            exp_year: 2025 + (Math.abs(seed) % 5)
                        },
                        customer: generateStripeId('cus_', Math.floor(seededRandom(seed) * counts.customers)),
                        created: generateRealisticTimestamp(seed + 1, 365)
                    };
                }),
                payment_intents: Array.from({length: Math.min(sampleSize, counts.charges)}, (_, i) => {
                    const seed = i * 7000;
                    const statuses = ['succeeded', 'requires_payment_method', 'requires_confirmation', 'canceled'];
                    return {
                        id: generateStripeId('pi_', seed),
                        amount: Math.floor(seededRandom(seed) * 10000) + 1000,
                        currency: 'usd',
                        status: statuses[Math.abs(seed) % statuses.length],
                        customer: generateStripeId('cus_', Math.floor(seededRandom(seed + 1) * counts.customers)),
                        created: generateRealisticTimestamp(seed + 2, 90)
                    };
                }),
                refunds: Array.from({length: Math.min(sampleSize, Math.floor(counts.charges * 0.1))}, (_, i) => {
                    const seed = i * 8000;
                    return {
                        id: generateStripeId('re_', seed),
                        amount: Math.floor(seededRandom(seed) * 5000) + 500,
                        currency: 'usd',
                        charge: generateStripeId('ch_', Math.floor(seededRandom(seed + 1) * counts.charges)),
                        reason: ['duplicate', 'fraudulent', 'requested_by_customer'][Math.abs(seed) % 3],
                        status: 'succeeded',
                        created: generateRealisticTimestamp(seed + 2, 60)
                    };
                }),
                disputes: Array.from({length: Math.min(sampleSize, Math.floor(counts.charges * 0.05))}, (_, i) => {
                    const seed = i * 9000;
                    const reasons = ['credit_not_processed', 'duplicate', 'fraudulent', 'general', 'incorrect_account_details'];
                    return {
                        id: generateStripeId('dp_', seed),
                        amount: Math.floor(seededRandom(seed) * 8000) + 1000,
                        currency: 'usd',
                        charge: generateStripeId('ch_', Math.floor(seededRandom(seed + 1) * counts.charges)),
                        reason: reasons[Math.abs(seed) % reasons.length],
                        status: ['warning_needs_response', 'warning_under_review', 'warning_closed', 'needs_response'][Math.abs(seed + 1) % 4],
                        created: generateRealisticTimestamp(seed + 2, 30)
                    };
                }),
                products: Array.from({length: Math.min(sampleSize, counts.plans)}, (_, i) => {
                    const seed = i * 10000;
                    const persona = PREDEFINED_PERSONAS[businessType];
                    return {
                        id: generateStripeId('prod_', seed),
                        name: `${persona.name} ${['Basic', 'Pro', 'Enterprise'][i % 3]} Plan`,
                        description: `${persona.description} - ${['Basic', 'Professional', 'Enterprise'][i % 3]} tier`,
                        active: true,
                        type: 'service',
                        created: generateRealisticTimestamp(seed + 1, 365)
                    };
                }),
                prices: Array.from({length: Math.min(sampleSize, counts.plans)}, (_, i) => {
                    const seed = i * 11000;
                    return {
                        id: generateStripeId('price_', seed),
                        product: generateStripeId('prod_', seed),
                        unit_amount: Math.floor(seededRandom(seed) * 5000) + 1000,
                        currency: 'usd',
                        recurring: {
                            interval: ['month', 'year'][Math.abs(seed) % 2],
                            interval_count: 1
                        },
                        active: true,
                        created: generateRealisticTimestamp(seed + 1, 365)
                    };
                }),
                coupons: Array.from({length: Math.min(sampleSize, Math.floor(counts.plans * 0.5))}, (_, i) => {
                    const seed = i * 12000;
                    return {
                        id: generateStripeId('coupon_', seed),
                        name: ['WELCOME10', 'SAVE20', 'NEWUSER', 'HOLIDAY25', 'UPGRADE15'][i % 5],
                        percent_off: [10, 15, 20, 25, 30][Math.abs(seed) % 5],
                        duration: ['once', 'repeating', 'forever'][Math.abs(seed) % 3],
                        valid: true,
                        created: generateRealisticTimestamp(seed + 1, 180)
                    };
                }),
                balance_transactions: Array.from({length: Math.min(sampleSize, Math.floor(counts.charges * 1.1))}, (_, i) => {
                    const seed = i * 13000;
                    const types = ['charge', 'refund', 'adjustment', 'application_fee', 'stripe_fee'];
                    return {
                        id: generateStripeId('txn_', seed),
                        amount: Math.floor(seededRandom(seed) * 10000) + 100,
                        currency: 'usd',
                        description: `${types[Math.abs(seed) % types.length]} transaction`,
                        fee: Math.floor(seededRandom(seed + 1) * 300) + 30,
                        net: Math.floor(seededRandom(seed + 2) * 9700) + 70,
                        status: 'available',
                        type: types[Math.abs(seed) % types.length],
                        created: generateRealisticTimestamp(seed + 3, 90)
                    };
                }),
                events: Array.from({length: Math.min(sampleSize, Math.floor(counts.charges * 0.8))}, (_, i) => {
                    const seed = i * 14000;
                    const eventTypes = ['charge.succeeded', 'payment_intent.succeeded', 'invoice.paid', 'customer.created', 'subscription.created'];
                    return {
                        id: generateStripeId('evt_', seed),
                        type: eventTypes[Math.abs(seed) % eventTypes.length],
                        data: {
                            object: {
                                id: generateStripeId('ch_', seed + 1),
                                amount: Math.floor(seededRandom(seed) * 10000) + 1000
                            }
                        },
                        created: generateRealisticTimestamp(seed + 2, 30),
                        livemode: false,
                        pending_webhooks: 1
                    };
                }),
                setup_intents: Array.from({length: Math.min(sampleSize, Math.floor(counts.customers * 0.3))}, (_, i) => {
                    const seed = i * 15000;
                    return {
                        id: generateStripeId('seti_', seed),
                        customer: generateStripeId('cus_', Math.floor(seededRandom(seed) * counts.customers)),
                        status: ['succeeded', 'requires_payment_method', 'requires_confirmation'][Math.abs(seed) % 3],
                        usage: 'off_session',
                        created: generateRealisticTimestamp(seed + 1, 60)
                    };
                }),
                _metadata: {
                    counts: {
                        customers: counts.customers,
                        charges: counts.charges,
                        subscriptions: counts.subscriptions,
                        invoices: counts.invoices,
                        plans: counts.plans,
                        payment_methods: Math.floor(counts.customers * 1.2),
                        payment_intents: counts.charges,
                        refunds: Math.floor(counts.charges * 0.1),
                        disputes: Math.floor(counts.charges * 0.05),
                        products: counts.plans,
                        prices: counts.plans,
                        coupons: Math.floor(counts.plans * 0.5),
                        balance_transactions: Math.floor(counts.charges * 1.1),
                        events: Math.floor(counts.charges * 0.8),
                        setup_intents: Math.floor(counts.customers * 0.3)
                    },
                    includedMetrics: [
                        'Gross Payment Volume',
                        'Payment Success Rate',
                        'Monthly Recurring Revenue',
                        'Customer Lifetime Value',
                        'Average Order Value',
                        'Conversion Rate',
                        'Successful Payments',
                        'Failed Card Payments - Failed Volume',
                        'Failed Card Payments - Failed Count',
                        'Failed Card Payments - Failure Rate',
                        'Active Subscribers',
                        'Subscription Revenue'
                    ]
                }
            };
            
            container.innerHTML = `
                <div class="mb-8">
                    <h3 class="text-xl font-semibold text-gray-900 mb-2">Dataset structure</h3>
                    <div class="mb-6">
                        <a href="https://docs.stripe.com/stripe-data/schema" target="_blank" rel="noopener noreferrer" class="text-sm underline flex items-center gap-1" style="color: #DB4F0B;">
                            Open data schema
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                            </svg>
                        </a>
                    </div>
                    <div class="space-y-6">
                        ${Object.entries(stripeData)
                            .filter(([dataType, dataArray]) => 
                                dataType !== '_metadata' && 
                                Array.isArray(dataArray) && 
                                dataArray.length > 0
                            )
                            .map(([dataType, dataArray]) => `
                            <div class="mb-6">
                                <h4 class="font-semibold text-gray-900 mb-3">
                                    ${dataType.charAt(0).toUpperCase() + dataType.slice(1)} (${(stripeData._metadata.counts[dataType] || dataArray.length || 0).toLocaleString()})
                                </h4>
                                <div class="space-y-0">
                                    ${dataArray.slice(0, 3).map((item, index) => `
                                        <div class="py-3 border-b border-gray-200 last:border-b-0">
                                            ${dataType === 'customers' ? `
                                                <div class="flex justify-between items-start">
                                                    <div class="flex-1">
                                                        <div class="font-medium text-gray-900">${item.name}</div>
                                                        <div class="text-sm text-gray-600">${item.email}</div>
                                                    </div>
                                                    <div class="text-xs text-gray-500">
                                                        ${new Date(item.created * 1000).toLocaleDateString()}
                                                    </div>
                                                </div>
                                            ` : `
                                                <div class="space-y-1">
                                                    ${Object.entries(item).slice(0, 6).map(([key, value]) => `
                                                        <div class="flex items-center">
                                                            <span class="text-sm font-medium text-gray-600 capitalize">
                                                                ${key}:
                                                            </span>
                                                            <span class="text-sm text-gray-900 ml-2">
                                                                ${typeof value === 'number' && key.includes('amount') 
                                                                    ? `$${(value / 100).toFixed(2)}`
                                                                    : typeof value === 'number' && key.includes('created')
                                                                    ? new Date(value * 1000).toLocaleDateString()
                                                                    : typeof value === 'string' && value.length > 30
                                                                    ? `${value.substring(0, 30)}...`
                                                                    : typeof value === 'object' && value !== null
                                                                    ? JSON.stringify(value).substring(0, 30) + '...'
                                                                    : String(value)
                                                                }
                                                            </span>
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            `}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Update included metrics display (EXACT SAME AS ORIGINAL NEXT-APP)
        function updateIncludedMetrics(businessType, stage) {
            console.log('updateIncludedMetrics called');
            const sampleData = generateSampleData(businessType, stage);
            console.log('Sample data generated:', sampleData);
            const includedMetrics = getIncludedMetrics(sampleData, businessType, stage);
            console.log('Included metrics:', includedMetrics);
            const container = document.getElementById('included-metrics-section');
            
            container.innerHTML = `
                <div class="mb-8">
                    <h3 class="text-xl font-semibold text-gray-900 mb-4">Included metrics</h3>
                    <div class="space-y-3">
                        ${includedMetrics.map(metric => `
                            <div class="flex items-center justify-between py-2 px-3 bg-gray-50 rounded-xl">
                                <span class="text-sm font-medium text-gray-900">${metric}</span>
                                <span class="text-xs text-gray-500 bg-gray-200 px-2 py-1 rounded-lg">
                                    Available
                                </span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Update display when configuration changes
        function updateConfiguration() {
            console.log('updateConfiguration called');
            const businessType = document.getElementById('scenario-select').value;
            const stage = document.getElementById('stage-select').value;
            console.log('Business type:', businessType, 'Stage:', stage);
            
            console.log('Calling updateStripeProducts');
            updateStripeProducts(businessType, stage);
            console.log('Calling updateDatasetStructure');
            updateDatasetStructure(businessType, stage);
            console.log('Calling updateIncludedMetrics');
            updateIncludedMetrics(businessType, stage);
            
            // Update integration prompts with new scenario data
            console.log('Updating integration prompts');
            updateIntegrationPromptsForScenario(businessType, stage);
            
            console.log('updateConfiguration completed');
        }

        // ============================================================================
        // COMPREHENSIVE INTEGRATION PROMPTS (RESTORED FROM ORIGINAL)
        // ============================================================================
        
        let currentDatasetUrl = null;
        let currentDatasetInfo = null;
        
        // Update integration prompts when scenario changes
        function updateIntegrationPromptsForScenario(businessType, stage) {
            // Generate new counts and metrics for the current scenario
            const counts = getRealisticCounts(businessType, stage);
            const patterns = getPersonaPatterns(businessType);
            const comprehensiveDataset = generateComprehensiveDataset(businessType, stage, counts, patterns);
            const includedMetrics = getIncludedMetrics(comprehensiveDataset, businessType, stage);
            
            // Generate new filename for the updated scenario
            const scenarioId = document.getElementById('scenario-id').value;
            const animals = ['cheetah', 'lion', 'eagle', 'tiger', 'wolf', 'bear', 'shark', 'dolphin', 'panther', 'leopard', 'jaguar', 'lynx', 'bobcat', 'cougar', 'puma', 'falcon', 'hawk', 'owl', 'raven', 'crow', 'swan', 'heron', 'egret', 'fox', 'coyote', 'jackal', 'hyena', 'mongoose', 'weasel', 'otter', 'seal', 'walrus', 'whale', 'orca', 'narwhal', 'beluga', 'elephant', 'rhino', 'hippo', 'giraffe', 'zebra', 'antelope', 'gazelle', 'buffalo', 'bison', 'yak', 'camel', 'llama', 'alpaca', 'deer'];
            const timestamp = Date.now().toString().slice(-6);
            const animal1 = animals[scenarioId % animals.length];
            const animal2 = animals[(scenarioId * 7) % animals.length];
            const filename = `${animal1}-${animal2}-${scenarioId}-${timestamp}.json`;
            
            // Create new dataset URL
            const datasetJson = JSON.stringify(comprehensiveDataset, null, 2);
            const blob = new Blob([datasetJson], { type: 'application/json' });
            currentDatasetUrl = URL.createObjectURL(blob);
            
            // Update currentDatasetInfo with new scenario data
            currentDatasetInfo = {
                recordCounts: counts,
                includedMetrics: includedMetrics,
                businessType: businessType,
                stage: stage,
                filename: filename
            };
            
            // Update the URL input field
            const urlInput = document.getElementById('url-input');
            if (urlInput) {
                urlInput.value = currentDatasetUrl;
            }
            
            // Update the integration content with the new data
            updateIntegrationContent('cursor');
        }
        
        // Tab switching
        const tabs = ['cursor', 'v0', 'claude', 'codex', 'javascript'];
        tabs.forEach(tab => {
            document.getElementById(`tab-${tab}`).addEventListener('click', () => {
                // Remove active class from all tabs
                tabs.forEach(t => {
                    const btn = document.getElementById(`tab-${t}`);
                    btn.className = btn.className.replace('bg-white text-gray-900 shadow-sm', 'text-gray-600 hover:text-gray-900');
                });
                // Add active class to clicked tab
                const activeBtn = document.getElementById(`tab-${tab}`);
                activeBtn.className = activeBtn.className.replace('text-gray-600 hover:text-gray-900', 'bg-white text-gray-900 shadow-sm');
                
                // Update integration content
                updateIntegrationContent(tab);
            });
        });
        
        
        // Copy URL
        document.getElementById('copy-url').addEventListener('click', () => {
            navigator.clipboard.writeText(currentDatasetUrl);
            alert('URL copied to clipboard!');
        });
        
        // Download dataset functionality removed - no longer needed
        
        // Update integration content with COMPREHENSIVE PROMPTS (RESTORED FROM ORIGINAL)
        function updateIntegrationContent(tab) {
            const content = document.getElementById('integration-content');
            if (!currentDatasetUrl || !currentDatasetInfo) {
                content.innerHTML = `
                    <div class="space-y-4">
                        <div class="p-4 bg-yellow-100 rounded-xl">
                            <p class="text-sm text-yellow-700">
                                âš ï¸ Please generate a dataset URL first by clicking "Generate Dataset URL" above to get integration code with the actual dataset.
                            </p>
                        </div>
                    </div>
                `;
                return;
            }
            
            const { recordCounts, includedMetrics, businessType, stage } = currentDatasetInfo;
            const recordSummary = Object.entries(recordCounts)
                .map(([key, count]) => `${count.toLocaleString()} ${key}`)
                .join(', ');
            const entityList = Object.keys(recordCounts).join(', ');
            const includedMetricsText = includedMetrics.join(', ');
            
            let integrationCode = '';
            switch(tab) {
                case 'cursor':
                    integrationCode = `
                        <div class="space-y-4">
                            <div class="bg-gray-100 p-5 rounded-xl">
                                <h4 class="font-semibold text-gray-900 mb-3">Cursor Integration Rules</h4>
                                <pre class="text-sm text-gray-800 overflow-x-auto"><code>// Add this to your .cursorrules file
When working with Synthkit data:
- Download the dataset JSON file from the site
- Import the dataset directly into your project
- Use the data without any external dependencies
- Dataset includes: ${recordSummary}
- Business Metrics: ${includedMetricsText}
- Stripe Data: Includes realistic Stripe objects (charges, subscriptions, invoices) with proper schema

**Technical Integration:**
1. **Download Dataset** - Click "Download Dataset JSON" to get the file
2. **Import Dataset** - Add the JSON file to your project (e.g., \`data/dataset.json\`)
3. **Use Data Directly** - Import and use without any hooks or API calls
4. **Replace Mock Data** - Update components to use imported dataset instead of hardcoded values
5. **Preserve Existing UI** - Keep all current components and styling, only change the data source
6. **No Dependencies** - No npm packages, no URLs, no environment variables needed

**Data Structure to Use:**
\`\`\javascript
// Import the downloaded dataset
import dataset from './data/dataset.json';

// Access data directly (no loading states needed)
const { customers, charges, subscriptions, invoices, plans, metrics } = dataset;

// Use in components
function MyComponent() {
  const recentCustomers = customers.slice(0, 10);
  const mrr = metrics.find(m => m.name === 'Monthly Recurring Revenue')?.value;
  
  return (
    <div>
      <h1>Recent Customers: {recentCustomers.length}</h1>
      <p>MRR: \${(mrr / 100).toFixed(0)}</p>
    </div>
  );
}
\`\`\`

**Integration Steps:**
1. Download dataset: Click "Download Dataset JSON" button
2. Save file: Add to your project (e.g., \`src/data/dataset.json\`)
3. Import data: \`import dataset from './data/dataset.json'\`
4. Access data: \`const { customers, charges, subscriptions, invoices, plans, metrics } = dataset;\`
5. Use in components: Replace mock data with dataset properties
6. Handle formatting: Convert cents to dollars (\`amount / 100\`)

**Stripe Integration Examples:**
- Display customers: \`dataset.customers.slice(0, 10).map(customer => ...)\`
- Show recent charges: \`dataset.charges.slice(0, 10).map(charge => ...)\`
- List active subscriptions: \`dataset.subscriptions.filter(sub => sub.status === 'active')\`
- Display recent invoices: \`dataset.invoices.slice(0, 5).map(invoice => ...)\`
- Show subscription plans: \`dataset.plans.map(plan => ...)\`
- Access metrics: \`dataset.metrics.find(m => m.name === 'Gross Payment Volume')\`
- Format amounts: \`\${(charge.amount / 100).toFixed(0)}\` (round numbers)

**Benefits:**
- Zero dependencies - no npm packages needed
- Immediate data - no loading states or API calls
- Complete dataset - includes all Stripe objects + calculated metrics
- Realistic data - persona-specific with proper relationships

Focus on **direct implementation** - show me exactly how to modify my existing components to use this dataset.</code></pre>
                            </div>
                        </div>
                    `;
                    break;
                case 'v0':
                    integrationCode = `
                        <div class="space-y-4">
                            <div class="bg-gray-100 p-5 rounded-xl">
                                <h4 class="font-semibold text-gray-900 mb-3">V0 Integration</h4>
                                <pre class="text-sm text-gray-800 overflow-x-auto"><code>Integrate this Synthkit dataset into my existing prototype by replacing mock data with realistic data.

**Dataset Information:**
- Dataset URL: \`${currentDatasetUrl}\`
- Data Volume: ${recordSummary}
- Business Type: ${businessType}
- Available Entities: ${entityList}
- Business Metrics: ${includedMetricsText}

**Integration Focus:**
- Replace existing mock/hardcoded data with real data from the dataset
- Keep all existing UI components and styling
- Only change the data source, not the design
- Maintain current component structure and layout

**Technical Integration:**
1. **Install Enhanced**: \`npm install @synthkit/enhanced\`
2. **Import the hook**: \`import { useSynthkit } from '@synthkit/enhanced/react';\`
3. **Replace data source**: Change from mock data to \`const { data, loading, error, customers, charges, subscriptions, invoices, plans } = useSynthkit();\`
4. **Update data references**: Replace hardcoded arrays with real data arrays
5. **Add loading states**: Handle loading and error states appropriately

**Data Access Pattern:**
\`\`\`javascript
// Replace your existing data fetching with this:
import { useSynthkit } from '@synthkit/enhanced/react';

// function YourExistingComponent() {
//   const { data, loading, error, customers, charges, subscriptions, invoices, plans } = useSynthkit();
//   
//   if (loading) return <div>Loading...</div>;
//   if (error) return <div>Error: {error.message}</div>;
//   
//   // Use the real data instead of mock data
//   // customers, charges, subscriptions, invoices, plans are now real data
// }
\`\`\`

**Real Data Available:**
${Object.entries(recordCounts).map(([key, count]) => `- ${key}: ${count.toLocaleString()} records`).join('\n')}
- Business metrics: CLV, AOV, MRR, conversion rate
- Comprehensive Stripe metrics: Payment volume, success rates, failed payments, etc.

**Integration Steps:**
1. Install: \`npm install @synthkit/enhanced\`
2. Import: \`import { useSynthkit } from '@synthkit/enhanced/react';\`
3. Replace: Change mock data to \`useSynthkit()\` hook
4. Update: Replace hardcoded data references with real data
5. Test: Verify the integration works with the actual dataset

Focus on **integrating the real data** into your existing prototype without changing the UI design.</code></pre>
                            </div>
                        </div>
                    `;
                    break;
                case 'claude':
                    integrationCode = `
                        <div class="space-y-4">
                            <div class="bg-gray-100 p-5 rounded-xl">
                                <h4 class="font-semibold text-gray-900 mb-3">Claude Integration</h4>
                                <pre class="text-sm text-gray-800 overflow-x-auto"><code>Dataset URL: ${currentDatasetUrl}

Integration steps:
1. Install: npm install @synthkit/enhanced
2. Import: import { getData } from '@synthkit/enhanced'
3. Use: const result = await getData()
4. Access: const { customers, charges, subscriptions } = result.data
5. Business Metrics: ${includedMetricsText}
6. Data Volume: ${recordSummary}

**Technical Integration:**
1. **Install Enhanced**: \`npm install @synthkit/enhanced\`
2. **Import the hook**: \`import { useSynthkit } from '@synthkit/enhanced/react';\`
3. **Replace data source**: Change from mock data to \`const { data, loading, error, customers, charges, subscriptions, invoices, plans } = useSynthkit();\`
4. **Update data references**: Replace hardcoded arrays with real data arrays
5. **Add loading states**: Handle loading and error states appropriately

**Data Access Pattern:**
\`\`\`javascript
// Replace your existing data fetching with this:
import { useSynthkit } from '@synthkit/enhanced/react';

// function YourExistingComponent() {
//   const { data, loading, error, customers, charges, subscriptions, invoices, plans } = useSynthkit();
//   
//   if (loading) return <div>Loading...</div>;
//   if (error) return <div>Error: {error.message}</div>;
//   
//   // Use the real data instead of mock data
//   // customers, charges, subscriptions, invoices, plans are now real data
// }
\`\`\`

**Real Data Available:**
${Object.entries(recordCounts).map(([key, count]) => `- ${key}: ${count.toLocaleString()} records`).join('\n')}
- Business metrics: CLV, AOV, MRR, conversion rate
- Comprehensive Stripe metrics: Payment volume, success rates, failed payments, etc.</code></pre>
                            </div>
                        </div>
                    `;
                    break;
                case 'codex':
                    integrationCode = `
                        <div class="space-y-4">
                            <div class="bg-gray-100 p-5 rounded-xl">
                                <h4 class="font-semibold text-gray-900 mb-3">ChatGPT Integration</h4>
                                <pre class="text-sm text-gray-800 overflow-x-auto"><code>Dataset URL: ${currentDatasetUrl}

Integration steps:
1. Install: npm install @synthkit/enhanced
2. Import: import { getData } from '@synthkit/enhanced'
3. Use: const result = await getData()
4. Access: const { customers, charges, subscriptions } = result.data
5. Business Metrics: ${includedMetricsText}
6. Data Volume: ${recordSummary}

**Technical Integration:**
1. **Install Enhanced**: \`npm install @synthkit/enhanced\`
2. **Import the hook**: \`import { useSynthkit } from '@synthkit/enhanced/react';\`
3. **Replace data source**: Change from mock data to \`const { data, loading, error, customers, charges, subscriptions, invoices, plans } = useSynthkit();\`
4. **Update data references**: Replace hardcoded arrays with real data arrays
5. **Add loading states**: Handle loading and error states appropriately

**Data Access Pattern:**
\`\`\`javascript
// Replace your existing data fetching with this:
import { useSynthkit } from '@synthkit/enhanced/react';

// function YourExistingComponent() {
//   const { data, loading, error, customers, charges, subscriptions, invoices, plans } = useSynthkit();
//   
//   if (loading) return <div>Loading...</div>;
//   if (error) return <div>Error: {error.message}</div>;
//   
//   // Use the real data instead of mock data
//   // customers, charges, subscriptions, invoices, plans are now real data
// }
\`\`\`

**Real Data Available:**
${Object.entries(recordCounts).map(([key, count]) => `- ${key}: ${count.toLocaleString()} records`).join('\n')}
- Business metrics: CLV, AOV, MRR, conversion rate
- Comprehensive Stripe metrics: Payment volume, success rates, failed payments, etc.</code></pre>
                            </div>
                        </div>
                    `;
                    break;
                case 'javascript':
                    integrationCode = `
                        <div class="space-y-4">
                            <div class="bg-gray-100 p-5 rounded-xl">
                                <h4 class="font-semibold text-gray-900 mb-3">Vanilla JavaScript Integration</h4>
                                <pre class="text-sm text-gray-800 overflow-x-auto"><code>// Install: npm install @synthkit/enhanced
import { getData } from '@synthkit/enhanced';

async function loadData() {
  const result = await getData();
  const { customers, charges, subscriptions } = result.data;
  
  console.log(\`Loaded \${customers.length} customers\`);
  console.log(\`Loaded \${charges.length} charges\`);
  console.log(\`Loaded \${subscriptions.length} subscriptions\`);
  
  // Use the data in your app
  return result.data;
}

// React integration
// import { useSynthkit } from '@synthkit/enhanced/react';

// function MyComponent() {
//   const { data, loading, error, customers, charges, subscriptions, invoices, plans } = useSynthkit();
//   
//   if (loading) return <div>Loading...</div>;
//   if (error) return <div>Error: {error.message}</div>;
//   
//   return (
//     <div>
//       <h2>Customers ({customers.length.toLocaleString()})</h2>
//       <h2>Charges ({charges.length.toLocaleString()})</h2>
//       <h2>Subscriptions ({subscriptions.length.toLocaleString()})</h2>
//     </div>
//   );
// }

// Dataset URL: ${currentDatasetUrl}
// Business Metrics: ${includedMetricsText}
// Data Volume: ${recordSummary}</code></pre>
                            </div>
                        </div>
                    `;
                    break;
            }
            
            content.innerHTML = integrationCode;
        }
        
        // Enable custom scenario generation
        const customScenarioInput = document.getElementById('custom-scenario');
        const generateCustomBtn = document.getElementById('generate-custom');
        if (customScenarioInput && generateCustomBtn) {
            customScenarioInput.addEventListener('input', (e) => {
                generateCustomBtn.disabled = !e.target.value.trim();
            });
        }
        
        // Update configuration when settings change
        document.getElementById('scenario-select').addEventListener('change', updateConfiguration);
        document.getElementById('stage-select').addEventListener('change', updateConfiguration);
        
        // Initialize display
        console.log('About to call updateConfiguration');
        try {
            updateConfiguration();
            console.log('updateConfiguration called successfully');
            
            // Auto-generate dataset for default scenario
            const defaultScenario = document.getElementById('scenario-select').value;
            const defaultStage = document.getElementById('stage-select').value;
            const defaultId = document.getElementById('scenario-id').value;
            
            // Generate filename
            const animals = ['cheetah', 'lion', 'eagle', 'tiger', 'wolf', 'bear', 'shark', 'dolphin', 'panther', 'leopard', 'jaguar', 'lynx', 'bobcat', 'cougar', 'puma', 'falcon', 'hawk', 'owl', 'raven', 'crow', 'swan', 'heron', 'egret', 'fox', 'coyote', 'jackal', 'hyena', 'mongoose', 'weasel', 'otter', 'seal', 'walrus', 'whale', 'orca', 'narwhal', 'beluga', 'elephant', 'rhino', 'hippo', 'giraffe', 'zebra', 'antelope', 'gazelle', 'buffalo', 'bison', 'yak', 'camel', 'llama', 'alpaca', 'deer'];
            const timestamp = Date.now().toString().slice(-6);
            const animal1 = animals[defaultId % animals.length];
            const animal2 = animals[(defaultId * 7) % animals.length];
            const filename = `${animal1}-${animal2}-${defaultId}-${timestamp}.json`;
            
            // Generate comprehensive dataset data
            const counts = getRealisticCounts(defaultScenario, defaultStage);
            const patterns = getPersonaPatterns(defaultScenario);
            const comprehensiveDataset = generateComprehensiveDataset(defaultScenario, defaultStage, counts, patterns);
            const includedMetrics = getIncludedMetrics(comprehensiveDataset, defaultScenario, defaultStage);
            
            // Create data URL for immediate download
            const datasetJson = JSON.stringify(comprehensiveDataset, null, 2);
            const blob = new Blob([datasetJson], { type: 'application/json' });
            currentDatasetUrl = URL.createObjectURL(blob);
            
            currentDatasetInfo = {
                recordCounts: counts,
                includedMetrics: includedMetrics,
                businessType: defaultScenario,
                stage: defaultStage,
                filename: filename
            };
            
            // Populate the dataset URL input field
            const urlInput = document.getElementById('url-input');
            if (urlInput) {
                urlInput.value = currentDatasetUrl;
            }
            
            // Update integration content to show Cursor tab by default
            updateIntegrationContent('cursor');
            
            // Activate Cursor tab (it's already active by default with bg-white class)
            // The tab switching is handled by the existing event listeners
            
            console.log('Default dataset generated and integration content updated');
            
        } catch (error) {
            console.error('Error in updateConfiguration:', error);
        }
    </script>
</body>
</html>
