# Synthkit Development Rules

## Code Style & Standards
- Use TypeScript with strict mode enabled
- Follow existing naming conventions (camelCase for variables, PascalCase for types)
- Prefer explicit types over `any` - use proper interfaces from @synthkit/sdk
- Use consistent error handling patterns with proper Error types
- Always use `error instanceof Error ? error.message : 'Unknown error'` for error handling

## Architecture Patterns
- CLI commands should extend Commander.js Command class
- Use the existing ConfigLoader and PackLoader utilities
- Follow the established pack structure in /packs directory
- Maintain separation between CLI tools and SDK packages
- Use the getPackLoader() and loadConfig() utilities consistently

## File Organization
- CLI commands go in tools/cli/src/commands/
- Utilities go in tools/cli/src/utils/
- Templates go in tools/cli/templates/
- Pack definitions go in packs/<pack-name>/
- Never modify core SDK types without discussion
- Keep generated files in generated-data/ directory

## Testing & Validation
- Always rebuild CLI after changes: `cd tools/cli && pnpm build`
- Test commands from synthkit root directory
- Validate pack structure with `synthkit pack validate`
- Use proper TypeScript compilation checks
- Test both interactive and non-interactive command modes

## Specific Patterns
- Use chalk for colored output consistently (chalk.blue, chalk.green, chalk.red, chalk.yellow, chalk.gray)
- Use inquirer for interactive prompts with proper validation
- Use fs-extra for file operations (fs.pathExists, fs.readJSON, fs.writeJSON, fs.ensureDir)
- Follow existing error message formatting with actionable next steps
- Maintain backward compatibility with existing configs
- Use path.join() for all file path operations

## CLI Command Patterns
- Use consistent option naming (-p for pack, -d for description, -f for force)
- Provide both short and long option forms
- Include examples in help text and descriptions
- Support both interactive and non-interactive modes
- Use proper argument validation with helpful error messages
- Always provide "Next steps" guidance after successful operations

## Output Formatting Standards
- Use emojis consistently: üöÄ for init, üìã for lists, ‚úÖ for success, ‚ö†Ô∏è for warnings, üéØ for activation
- Structure output with clear sections using chalk.cyan() for headers
- Use consistent indentation (2 spaces for nested items)
- Always end with actionable next steps or related commands

## Before Making Changes
1. Ask: "Does this change maintain compatibility with existing packs?"
2. Ask: "Will this require updates to documentation?"
3. Ask: "Does this follow the established CLI command patterns?"
4. Ask: "Have I tested this with the existing synthkit project?"
5. Ask: "Does this maintain the established UX patterns?"

## Code Review Checklist
- [ ] Follows existing error handling patterns
- [ ] Uses proper TypeScript types (no `any` unless necessary with proper casting)
- [ ] Maintains CLI command consistency
- [ ] Includes proper help text and examples
- [ ] Tests pass with `pnpm build`
- [ ] No breaking changes to public APIs
- [ ] Uses established utility functions

## Forbidden Actions
- Don't modify package.json dependencies without approval
- Don't change core type definitions in @synthkit/sdk
- Don't create new top-level directories
- Don't modify existing pack schemas without migration plan
- Don't use console.log - use chalk for formatted output
- Don't use relative imports across package boundaries
- Don't hardcode file paths - use ConfigLoader.getProjectRoot()

## Synthkit-Specific Rules

### Pack Development
- Pack IDs must be lowercase, hyphenated
- All packs must have pack.json with required fields: id, name, description, version, schemas
- Scenarios must follow the established Scenario interface
- Schemas must be valid JSON Schema v7
- Use existing pack structure as templates

### CLI Commands
- Use consistent option naming (-p for pack, -d for description, --force for overrides)
- Provide both short and long option forms where appropriate
- Include examples in help text with real pack names
- Support both interactive and non-interactive modes
- Always validate required options with helpful error messages

### Data Generation
- Always use deterministic seeds for reproducibility
- Respect locale settings from configuration
- Follow established volume patterns from existing scenarios
- Maintain referential integrity in generated data
- Use the established GenerationContext interface

### Error Handling
- Use chalk.red() for errors with clear problem description
- Use chalk.yellow() for warnings that don't stop execution
- Use chalk.green() for success messages with confirmation
- Use chalk.gray() for supplementary information and next steps
- Provide actionable error messages with specific commands to run

### Configuration Management
- Always use ConfigLoader.getInstance() for config operations
- Use loadConfig() utility function for loading configuration
- Cast config properties as needed: (config as any).scenarios
- Save config changes with configLoader.saveConfig()
- Validate config structure before saving

### Pack Loading
- Use getPackLoader() to get the PackLoader instance
- Use packLoader.discoverPacks(['packs/*']) for pack discovery
- Handle pack loading errors gracefully with warnings
- Check pack.scenarios and pack.schemas existence before accessing

## Context Awareness
When working on:
- CLI commands: Reference existing commands in tools/cli/src/commands/
- Pack development: Check existing packs in /packs directory for patterns
- Type definitions: Use types from @synthkit/sdk and tools/cli/src/utils/
- Configuration: Follow synth.config.json schema and CLIConfig interface
- Templates: Use existing templates in tools/cli/templates/ as reference

## Always Check
- Does this change affect other CLI commands?
- Are there existing utilities I should use instead of creating new ones?
- Does this maintain the established UX patterns and output formatting?
- Will this work with all existing packs (core, saas, ecomm)?
- Have I used the proper TypeScript types and error handling?

## Git Workflow
- Always run `pnpm build` in tools/cli before committing
- Use conventional commit messages: feat:, fix:, docs:, refactor:, etc.
- Include tests for new CLI commands when possible
- Update help text when adding new options
- Test commands with real scenarios before committing

## Commit Message Format
```
feat(cli): add new scenario management command
fix(pack): resolve validation issue with schemas  
docs(readme): update CLI usage examples
refactor(utils): improve error handling consistency
```

## File Path Conventions
- Use absolute paths when calling tools: `/Users/nicholasswanson/synthkit/tools/cli/dist/cli.js`
- Use relative paths within package: `./src/commands/`
- Always use path.join() for cross-platform compatibility
- Store snapshots in `.synthkit/snapshots/` directory
- Store generated data in `generated-data/` directory

## Testing Commands
Always test new CLI functionality with these patterns:
```bash
cd /Users/nicholasswanson/synthkit
tools/cli/dist/cli.js <command> --help
tools/cli/dist/cli.js <command> <args>
tools/cli/dist/cli.js pack validate  # Ensure no regressions
```
